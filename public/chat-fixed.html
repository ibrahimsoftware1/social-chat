<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://js.pusher.com/8.2.0/pusher.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/laravel-echo@1.15.3/dist/echo.iife.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .app-container {
            width: 100%;
            max-width: 900px;
            margin: 20px;
        }

        .login-card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 400px;
            margin: 0 auto;
        }

        .chat-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
            height: 600px;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: #ef4444;
            animation: none;
        }

        .status-dot.warning {
            background: #f59e0b;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .messages-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8fafc;
        }

        .message {
            margin-bottom: 20px;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }

        .message.own {
            flex-direction: row-reverse;
        }

        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            background: #e5e7eb;
            color: #374151;
            word-wrap: break-word;
            position: relative;
        }

        .message.own .message-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message-info {
            font-size: 11px;
            color: #6b7280;
            margin-top: 4px;
        }

        .message.own .message-info {
            text-align: right;
            color: rgba(255,255,255,0.8);
        }

        .typing-indicator {
            padding: 10px 20px;
            color: #6b7280;
            font-style: italic;
            min-height: 40px;
            display: flex;
            align-items: center;
            background: #f1f5f9;
            border-top: 1px solid #e2e8f0;
        }

        .typing-dots {
            display: inline-flex;
            gap: 4px;
            margin-left: 8px;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #6b7280;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }

        .message-input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: all 0.2s;
        }

        .message-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .send-button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .send-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .login-input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            outline: none;
            transition: all 0.2s;
        }

        .login-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .login-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .login-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .error-message {
            background: #fee2e2;
            color: #dc2626;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #fecaca;
        }

        .no-messages {
            text-align: center;
            color: #6b7280;
            padding: 60px 20px;
            font-style: italic;
        }

        .logout-button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .logout-button:hover {
            background: rgba(255,255,255,0.3);
        }

        h1 {
            margin-bottom: 10px;
            color: #1f2937;
        }

        .conversation-title {
            font-size: 18px;
            font-weight: 600;
        }

        .debug-info {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }

        .conversation-selector {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .conversation-item {
            padding: 12px 16px;
            border-radius: 10px;
            background: #f8fafc;
            color: #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .conversation-item:hover {
            background: #e2e8f0;
        }

        .conversation-info {
            flex: 1;
            margin-right: 10px;
        }

        .conversation-meta {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .selected-conversation {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .create-conversation-button {
            padding: 12px 24px;
            background: #4ade80;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .create-conversation-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(72, 187, 120, 0.3);
        }

        .create-conversation-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .go-back-button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .go-back-button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateX(-2px);
        }

        .close-button {
            background: #6b7280;
            border: 1px solid #9ca3af;
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .close-button:hover {
            background: #4b5563;
            transform: translateX(-2px);
        }
    </style>
</head>
<body>
    <div id="app" class="app-container">
        <!-- Login Screen -->
        <div v-if="!isAuthenticated" class="login-card">
            <h1>üí¨ Fixed Real-time Chat</h1>
            <p style="color: #6b7280; margin-bottom: 30px;">Login to start chatting</p>

            <input
                v-model="loginEmail"
                type="email"
                placeholder="Email address"
                class="login-input"
                @keyup.enter="login"
            >

            <input
                v-model="loginPassword"
                type="password"
                placeholder="Password"
                class="login-input"
                @keyup.enter="login"
            >

            <button @click="login" class="login-button">
                Sign In
            </button>

            <div v-if="error" class="error-message">
                {{ error }}
            </div>
        </div>

        <!-- Chat Interface -->
        <div v-else class="chat-container">
            <!-- Header -->
            <div class="chat-header">
                <div>
                    <div class="conversation-title">Conversation #{{ conversationId }}</div>
                    <div class="connection-status">
                        <div class="status-dot" :class="{
                            disconnected: !isConnected,
                            warning: isConnected && !isChannelSubscribed
                        }"></div>
                        <span v-if="isConnected && isChannelSubscribed">Connected as {{ user.name }}</span>
                        <span v-else-if="isConnected && !isChannelSubscribed">Channel Subscribing...</span>
                        <span v-else>Connecting...</span>
                        <div class="debug-info">
                            Socket: {{ socketId || 'N/A' }} | Subscribed: {{ isChannelSubscribed ? 'Yes' : 'No' }}
                        </div>
                    </div>
                </div>
                <button @click="logout" class="logout-button">
                    Logout
                </button>
            </div>

            <!-- Conversation Selector -->
            <div v-if="showConversationSelector" class="conversation-selector">
                <h2 style="font-size: 16px; margin-bottom: 12px;">Select a Conversation</h2>

                <div
                    v-for="conversation in conversations"
                    :key="conversation.id"
                    class="conversation-item"
                    :class="{ 'selected-conversation': conversation.id === selectedConversationId }"
                    @click="selectConversation(conversation)"
                    style="margin-bottom: 8px;"
                >
                    <div class="conversation-info">
                        <div class="conversation-title">
                            {{ conversation.name || `Conversation #${conversation.id}` }}
                        </div>
                        <div class="conversation-meta">
                            <span>{{ conversation.type === 'group' ? 'üë• Group' : 'üë§ P2P' }}</span> ‚Ä¢
                            <span>{{ conversation.last_message_at ? formatTime(conversation.last_message_at) : 'No messages' }}</span>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 16px;">
                    <button
                        @click="createConversation"
                        class="create-conversation-button"
                        :disabled="!user"
                    >
                        ‚ûï New Conversation
                    </button>
                </div>
            </div>

            <!-- Messages Area -->
            <div v-if="!showConversationSelector" class="messages-area" ref="messagesContainer">
                <div v-if="messages.length === 0" class="no-messages">
                    No messages yet. Start the conversation! üëã
                </div>

                <div
                    v-for="message in messages"
                    :key="message.id"
                    class="message"
                    :class="{ own: message.user_id === user.id }"
                >
                    <div>
                        <div class="message-bubble">
                            {{ message.content }}
                        </div>
                        <div class="message-info">
                            {{ getUserName(message) }} ‚Ä¢ {{ formatTime(message.created_at) }}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Typing Indicator -->
            <div v-if="!showConversationSelector" class="typing-indicator">
                <span v-if="typingUser">
                    {{ typingUser }} is typing
                    <span class="typing-dots">
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                    </span>
                </span>
            </div>

            <!-- Message Input -->
            <div v-if="!showConversationSelector" class="message-input-area">
                <button @click="showConversationSelector = true" class="close-button" style="margin-right: 10px;">
                    ‚Üê Back
                </button>
                <input
                    v-model="newMessage"
                    type="text"
                    placeholder="Type your message..."
                    class="message-input"
                    @keyup.enter="sendMessage"
                    @input="handleTyping"
                    @keydown="handleTyping"
                >
                <button
                    @click="sendMessage"
                    :disabled="!newMessage.trim() || !isChannelSubscribed"
                    class="send-button"
                >
                    Send
                </button>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    // Authentication
                    isAuthenticated: false,
                    user: null,
                    token: null,
                    loginEmail: '',
                    loginPassword: '',
                    error: null,

                    // Conversation Selection
                    showConversationSelector: true,
                    conversations: [],
                    selectedConversationId: null,
                    conversationType: null, // 'private' or 'group'

                    // Chat
                    conversationId: null,
                    messages: [],
                    newMessage: '',
                    conversationInfo: null,

                    // Real-time
                    echo: null,
                    channel: null,
                    isConnected: false,
                    isChannelSubscribed: false,
                    socketId: null,
                    typingUser: null,
                    isTyping: false,
                    typingTimer: null,
                    lastTypingTime: 0,
                    connectionRetries: 0,
                    maxRetries: 3,

                    // Config
                    apiBaseUrl: 'http://localhost:8000/api'
                }
            },

            methods: {
                async login() {
                    try {
                        this.error = null;
                        console.log('üîê Attempting login...');

                        const response = await axios.post(`${this.apiBaseUrl}/login`, {
                            email: this.loginEmail,
                            password: this.loginPassword
                        });

                        // Extract token and user from response
                        const data = response.data.data || response.data;
                        this.token = data.access_token;
                        this.user = data.user;
                        this.isAuthenticated = true;

                        console.log('‚úÖ Login successful:', this.user.name, 'ID:', this.user.id);

                        // Set authorization header
                        axios.defaults.headers.common['Authorization'] = `Bearer ${this.token}`;

                        // Small delay before initializing real-time
                        setTimeout(() => {
                            this.initializeRealtime();
                        }, 1000);

                        // Only load conversations, not messages (since no conversation is selected yet)
                        await this.loadConversations();

                    } catch (error) {
                        console.error('‚ùå Login failed:', error);
                        this.error = error.response?.data?.message || 'Login failed. Please check your credentials.';
                    }
                },

                async initializeRealtime() {
                    console.log('üöÄ Initializing real-time connection...');

                    try {
                        // Initialize Echo with retry mechanism
                        await this.setupEcho();

                    } catch (error) {
                        console.error('‚ùå Real-time initialization failed:', error);

                        if (this.connectionRetries < this.maxRetries) {
                            this.connectionRetries++;
                            console.log(`üîÑ Retrying connection (${this.connectionRetries}/${this.maxRetries})...`);
                            setTimeout(() => this.initializeRealtime(), 3000);
                        } else {
                            console.error('‚ùå Max retries reached. Real-time connection failed.');
                        }
                    }
                },

                async setupEcho() {
                    return new Promise((resolve, reject) => {
                        try {
                            // Initialize Echo
                            window.Echo = new Echo({
                                broadcaster: 'pusher',
                                key: 'w3ega2dc8ka76bwzaxvh',
                                wsHost: '127.0.0.1',
                                wsPort: 8080,
                                wssPort: 8080,
                                forceTLS: false,
                                encrypted: false,
                                disableStats: true,
                                enabledTransports: ['ws', 'wss'],
                                cluster: 'mt1',
                                auth: {
                                    headers: {
                                        Authorization: `Bearer ${this.token}`,
                                        Accept: 'application/json'
                                    }
                                },
                                authEndpoint: `${this.apiBaseUrl}/broadcasting/auth`
                            });

                            this.echo = window.Echo;
                            console.log('‚úÖ Echo initialized');

                            // Bind connection events
                            if (this.echo.connector?.pusher?.connection) {
                                this.echo.connector.pusher.connection.bind('connected', () => {
                                    console.log('üü¢ WebSocket connected');
                                    this.isConnected = true;
                                    this.socketId = this.echo.connector.pusher.connection.socket_id;
                                    console.log('üîå Socket ID:', this.socketId);

                                    // Connect to channel after WebSocket is connected
                                    setTimeout(() => this.connectToChannel(), 500);
                                    resolve();
                                });

                                this.echo.connector.pusher.connection.bind('disconnected', () => {
                                    console.log('üî¥ WebSocket disconnected');
                                    this.isConnected = false;
                                    this.isChannelSubscribed = false;
                                    this.socketId = null;
                                });

                                this.echo.connector.pusher.connection.bind('error', (error) => {
                                    console.error('‚ùå WebSocket error:', error);
                                    this.isConnected = false;
                                    this.isChannelSubscribed = false;
                                    reject(error);
                                });

                                this.echo.connector.pusher.connection.bind('failed', (error) => {
                                    console.error('üíÄ WebSocket connection failed:', error);
                                    reject(error);
                                });
                            } else {
                                console.warn('‚ö†Ô∏è Pusher connection not available, using fallback');
                                // Fallback - assume connected after a delay
                                setTimeout(() => {
                                    this.isConnected = true;
                                    this.connectToChannel();
                                    resolve();
                                }, 2000);
                            }

                        } catch (error) {
                            console.error('‚ùå Echo setup failed:', error);
                            reject(error);
                        }
                    });
                },

                connectToChannel() {
                    if (!this.echo || !this.conversationId) {
                        console.log('‚ùå Echo not initialized or no conversation selected');
                        return;
                    }

                    console.log(`üì° Connecting to private-conversation.${this.conversationId}...`);
                    console.log(`üë§ User ID: ${this.user.id}, Socket: ${this.socketId}`);

                    try {
                        this.channel = this.echo.private(`conversation.${this.conversationId}`)
                            .subscribed(() => {
                                console.log('‚úÖ Successfully subscribed to private channel');
                                this.isChannelSubscribed = true;
                            })
                            .listen('.message.sent', (event) => {
                                console.log('üì® Message event received:', event);
                                console.log(`üÜî Message from user ${event.message?.user_id}, my ID: ${this.user.id}`);

                                // Only add message if it's from another user
                                if (event.message && event.message.user_id !== this.user.id) {
                                    console.log('‚ûï Adding message from other user:', event.message.content);
                                    this.messages.push(event.message);
                                    this.$nextTick(() => this.scrollToBottom());
                                } else {
                                    console.log('‚è≠Ô∏è Ignoring own message');
                                }
                            })
                            .listen('.user.typing', (event) => {
                                console.log('‚å®Ô∏è Typing event:', event);

                                if (event.user_id !== this.user.id) {
                                    this.typingUser = event.user_name;

                                    if (this.typingTimer) {
                                        clearTimeout(this.typingTimer);
                                    }

                                    this.typingTimer = setTimeout(() => {
                                        this.typingUser = null;
                                    }, 3000);
                                }
                            })
                            .listen('.user.stopped.typing', (event) => {
                                console.log('‚èπÔ∏è Stopped typing event:', event);

                                if (event.user_id !== this.user.id) {
                                    this.typingUser = null;
                                    if (this.typingTimer) {
                                        clearTimeout(this.typingTimer);
                                        this.typingTimer = null;
                                    }
                                }
                            })
                            .error((error) => {
                                console.error('‚ùå Channel subscription error:', error);
                                this.isChannelSubscribed = false;

                                // Retry channel subscription
                                setTimeout(() => {
                                    console.log('üîÑ Retrying channel subscription...');
                                    this.connectToChannel();
                                }, 3000);
                            });

                        console.log('‚úÖ Channel listeners attached');

                    } catch (error) {
                        console.error('‚ùå Channel connection failed:', error);
                        this.isChannelSubscribed = false;
                    }
                },

                async loadConversations() {
                    try {
                        console.log('üìã Loading conversations...');

                        const response = await axios.get(`${this.apiBaseUrl}/conversations`);

                        // The API returns paginated data, so we need to access the data correctly
                        const responseData = response.data.data || response.data;
                        this.conversations = responseData.data || responseData;

                        console.log('‚úÖ Loaded conversations:', this.conversations.length);
                        console.log('Conversations:', this.conversations);

                        // If user has conversations but none selected, show selector
                        if (this.conversations.length > 0 && !this.conversationId) {
                            this.showConversationSelector = true;
                        } else if (this.conversations.length === 0) {
                            console.log('No conversations found, showing selector for new conversation creation');
                            this.showConversationSelector = true;
                        }

                    } catch (error) {
                        console.error('‚ùå Failed to load conversations:', error);
                        console.error('Error response:', error.response?.data);
                        this.conversations = [];

                        // Show conversation selector even if loading fails, so user can create new ones
                        this.showConversationSelector = true;
                    }
                },

                async loadMessages() {
                    try {
                        console.log('üì• Loading existing messages...');

                        const response = await axios.get(`${this.apiBaseUrl}/conversations/${this.conversationId}/messages`);
                        this.messages = response.data.data.data.reverse();

                        console.log(`‚úÖ Loaded ${this.messages.length} messages`);
                        this.$nextTick(() => this.scrollToBottom());

                    } catch (error) {
                        console.error('‚ùå Failed to load messages:', error);
                    }
                },

                async sendMessage() {
                    if (!this.newMessage.trim() || !this.isChannelSubscribed) return;

                    const messageContent = this.newMessage.trim();
                    this.newMessage = '';

                    try {
                        console.log('üì§ Sending message:', messageContent);

                        const response = await axios.post(
                            `${this.apiBaseUrl}/messages/conversations/${this.conversationId}`,
                            {
                                content: messageContent,
                                type: 'text',
                                metadata: null
                            }
                        );

                        // Add own message immediately to UI
                        this.messages.push(response.data.data);
                        this.$nextTick(() => this.scrollToBottom());

                        console.log('‚úÖ Message sent successfully');

                    } catch (error) {
                        console.error('‚ùå Failed to send message:', error);
                        // Restore message on failure
                        this.newMessage = messageContent;
                    }
                },

                handleTyping() {
                    if (!this.isConnected || !this.isChannelSubscribed) return;

                    const now = Date.now();

                    // Only send typing event every 2 seconds max
                    if (!this.isTyping || (now - this.lastTypingTime) > 2000) {
                        this.isTyping = true;
                        this.lastTypingTime = now;

                        axios.post(`${this.apiBaseUrl}/messages/conversations/${this.conversationId}/typing`)
                            .catch(() => {}); // Ignore errors

                        console.log('‚å®Ô∏è Typing event sent');
                    }

                    // Auto-stop typing after 2 seconds of inactivity
                    if (this.typingTimer) {
                        clearTimeout(this.typingTimer);
                    }

                    this.typingTimer = setTimeout(() => {
                        if (this.isTyping) {
                            this.isTyping = false;
                            axios.post(`${this.apiBaseUrl}/messages/conversations/${this.conversationId}/stop-typing`)
                                .catch(() => {}); // Ignore errors
                            console.log('‚èπÔ∏è Stop typing event sent');
                        }
                    }, 2000);
                },

                logout() {
                    console.log('üëã Logging out...');

                    if (this.echo && this.channel) {
                        this.echo.leave(`conversation.${this.conversationId}`);
                    }

                    // Reset state
                    this.isAuthenticated = false;
                    this.user = null;
                    this.token = null;
                    this.messages = [];
                    this.conversations = [];
                    this.selectedConversationId = null;
                    this.isConnected = false;
                    this.isChannelSubscribed = false;
                    this.socketId = null;
                    this.typingUser = null;
                    this.newMessage = '';
                    this.error = null;
                    this.connectionRetries = 0;

                    // Clear axios header
                    delete axios.defaults.headers.common['Authorization'];

                    console.log('‚úÖ Logged out successfully');
                },

                scrollToBottom() {
                    const container = this.$refs.messagesContainer;
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }
                },

                getUserName(message) {
                    return message.user?.name || `User ${message.user_id}`;
                },

                formatTime(timestamp) {
                    return new Date(timestamp).toLocaleTimeString('en-US', {
                        hour: 'numeric',
                        minute: '2-digit'
                    });
                },

                selectConversation(conversation) {
                    console.log('üìÇ Selecting conversation:', conversation);

                    // Disconnect from previous channel if exists
                    if (this.echo && this.channel && this.conversationId) {
                        this.echo.leave(`conversation.${this.conversationId}`);
                        this.isChannelSubscribed = false;
                    }

                    this.selectedConversationId = conversation.id;
                    this.conversationId = conversation.id;
                    this.conversationType = conversation.type;
                    this.messages = []; // Clear previous messages
                    this.typingUser = null;

                    // Hide conversation selector
                    this.showConversationSelector = false;

                    // Load messages for the selected conversation
                    this.loadMessages();

                    // Subscribe to the channel for the selected conversation
                    setTimeout(() => this.connectToChannel(), 500);
                },

                async createConversation() {
                    const title = prompt('Enter conversation title:');
                    if (!title?.trim()) return;

                    const type = confirm('Create a group conversation? (Cancel for private chat)') ? 'group' : 'private';

                    try {
                        console.log('üÜï Creating new conversation...');

                        // For private conversations, we need another user ID
                        // For now, let's create group conversations or ask for user ID
                        let user_ids = [this.user.id]; // Always include self

                        if (type === 'private') {
                            const otherUserId = prompt('Enter the ID of the user you want to chat with:');
                            if (!otherUserId || isNaN(otherUserId)) {
                                alert('Invalid user ID. Please enter a valid number.');
                                return;
                            }
                            user_ids.push(parseInt(otherUserId));
                        }

                        const response = await axios.post(`${this.apiBaseUrl}/conversations`, {
                            name: title.trim(), // Backend expects 'name', not 'title'
                            type: type,
                            description: null,
                            user_ids: user_ids // Backend expects 'user_ids', not 'participants'
                        });

                        console.log('‚úÖ Conversation created:', response.data.data);

                        // Reload conversations to get the updated list
                        await this.loadConversations();

                        // Auto-select the new conversation
                        const newConversation = response.data.data;
                        this.selectConversation(newConversation);

                    } catch (error) {
                        console.error('‚ùå Failed to create conversation:', error);
                        console.error('Error response:', error.response?.data);

                        const errorMessage = error.response?.data?.message || 'Failed to create conversation. Please try again.';
                        alert(errorMessage);
                    }
                }
            }
        }).mount('#app');
    </script>
</body>
</html>
